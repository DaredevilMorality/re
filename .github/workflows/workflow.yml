name: workflow

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-2022
    timeout-minutes: 9999

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      continue-on-error: true

    - name: Setup
      shell: pwsh
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1

        net user administrator ${{ secrets.ADMIN_PASSWORD }} /add
        net localgroup administrators administrator /add
      continue-on-error: true

    - name: Add 
      shell: pwsh
      run: |
        $WshShell = New-Object -comObject WScript.Shell
        $Shortcut = $WshShell.CreateShortcut("C:\Users\Public\Desktop\Chrome_Reddit.lnk")
        $Shortcut.TargetPath = "C:\Program Files\Google\Chrome\Application\chrome.exe"
        $Shortcut.Arguments = "--no-first-run https://reddit.com https://guerrillamail.com"
        $Shortcut.Save()
      continue-on-error: true

    - name: Install
      shell: pwsh
      run: |
        Expand-Archive nssm-2.24.zip -DestinationPath .\nssm
        $nssmDir = Get-ChildItem -Path .\nssm -Directory | Select-Object -First 1
        $nssmExe = Get-ChildItem -Path $nssmDir.FullName -Filter nssm.exe -Recurse | Select-Object -First 1
        Copy-Item -Path $nssmExe.FullName -Destination .\nssm.exe
      continue-on-error: true

    - name: Install cloudflared
      shell: pwsh
      run: |
        .\nssm.exe install cloudflared $PWD\cloudflared.exe "tunnel --url rdp://localhost:3389"
        .\nssm.exe set cloudflared AppDirectory $PWD
        .\nssm.exe set cloudflared AppExit Default Restart
        .\nssm.exe set cloudflared AppStdout $PWD\cloudflared-log.log
        .\nssm.exe set cloudflared AppStderr $PWD\cloudflared-log.log
        .\nssm.exe start cloudflared
      continue-on-error: true

    - name: Wait
      shell: pwsh
      run: |
        $found = $false
        while (-not $found) {
          Start-Sleep -Milliseconds 100
          $logContent = Get-Content "$PWD\cloudflared-log.log" -Raw
          if ($logContent -match "(https:\/\/[a-zA-Z0-9\-]+\.trycloudflare\.com)") {
            $tunnelURL = $matches[1]
            $found = $true
          }
        }

        # Get GitHub Actions run ID
        $run_id = $env:GITHUB_RUN_ID

        # Send tunnel URL to the server
        $server_url = "${{ secrets.SERVER_URL }}/update-run/$run_id"
        $server_secret = "${{ secrets.SERVER_SECRET }}"
        $headers = @{
          "Authorization" = "Bearer $server_secret"
          "Content-Type"  = "application/json"
        }
        $body = @{
          "tunnel_url" = $tunnelURL
        } | ConvertTo-Json

        Invoke-RestMethod -Uri $server_url -Method POST -Headers $headers -Body $body

      continue-on-error: true

    - name: Download
      shell: pwsh
      run: |
        Invoke-WebRequest -Uri "https://1111-releases.cloudflareclient.com/win/latest" -OutFile "Cloudflare_WARP_Release-x64.msi"
        msiexec /i "Cloudflare_WARP_Release-x64.msi" /qn
      continue-on-error: true

    - name: Extract
      shell: pwsh
      run: |
        $ipAddress = ""
        while (-not $ipAddress) {
          Start-Sleep -Milliseconds 100
          $logLines = Get-Content "$PWD\cloudflared-log.log"
          foreach ($line in $logLines) {
            if ($line -match "ip=(\d{1,3}(?:\.\d{1,3}){3})") {
              $ipAddress = $matches[1]
              break
            }
          }
        }

        Add-Content -Path $env:GITHUB_ENV -Value "TUNNEL_IP=$ipAddress"

      continue-on-error: true

    - name: Create
      shell: pwsh
      run: |
        $batchContent = @"
        @echo off
        set "warpCliPath=C:\Program Files\Cloudflare\Cloudflare WARP\warp-cli.exe"
        "%warpCliPath%" registration new
        "%warpCliPath%" mode warp
        "%warpCliPath%" tunnel ip add $env:TUNNEL_IP
        "%warpCliPath%" connect
        pause
        "@
        
        Set-Content -Path "C:\Users\Public\Desktop\Cloudflare_WARP.bat" -Value $batchContent
      continue-on-error: true

    - name: Add 2
      shell: pwsh
      run: |
        $WshShell   = New-Object -ComObject WScript.Shell
        $linkPath    = "C:\Users\Public\Desktop\Cloudflare_WARP_Installer.lnk"
        $targetMsI   = "$PWD\Cloudflare_WARP_Release-x64.msi"
        $Shortcut    = $WshShell.CreateShortcut($linkPath)
        $Shortcut.TargetPath = $targetMsI
        $Shortcut.Description = "Cloudflare WARP Installer"
        $Shortcut.Save()
      continue-on-error: true

    - name: Configure administrator desktop and dark mode
      shell: pwsh
      continue-on-error: true
      run: |
        $ErrorActionPreference = 'Stop'

        $username = "administrator"
        $profilePath = "C:\Users\$username"
        $defaultProfile = "C:\Users\Default"
        $bmpPath = "C:\Windows\Temp\black_wallpaper.bmp"

        Write-Output "=> Ensure user exists"
        $user = Get-LocalUser -Name $username -ErrorAction SilentlyContinue
        if (-not $user) {
          Write-Warning "User '$username' not found in this session. The rest of the steps will still attempt to prepare the profile; ensure the user exists on the machine."
        }

        Write-Output "=> Ensure profile directory exists (copy Default if necessary)"
        if (-not (Test-Path $profilePath)) {
          New-Item -Path $profilePath -ItemType Directory -Force | Out-Null
          # Use robocopy to preserve ACLs and attributes where possible
          robocopy $defaultProfile $profilePath /E /COPYALL /R:3 /W:1 | Out-Null
          if (-not (Test-Path "$profilePath\NTUSER.DAT")) {
            Copy-Item -Path "$defaultProfile\NTUSER.DAT" -Destination "$profilePath\NTUSER.DAT" -Force
          }
          # Set ownership/ACL to the new user
          try {
            icacls $profilePath /setowner $username /T /C | Out-Null
            icacls $profilePath /grant "$username:(OI)(CI)F" /T /C | Out-Null
          } catch {
            Write-Warning "Failed to set ACL/owner on $profilePath: $_"
          }
        } else {
          Write-Output "Profile already exists at $profilePath"
        }

        Write-Output "=> Create a black BMP for wallpaper"
        if (-not (Test-Path "C:\Windows\Temp")) { New-Item -Path "C:\Windows\Temp" -ItemType Directory -Force | Out-Null }
        Add-Type -AssemblyName System.Drawing
        $width = 1920; $height = 1080
        $bmp = New-Object System.Drawing.Bitmap($width, $height)
        $g = [System.Drawing.Graphics]::FromImage($bmp)
        $g.Clear([System.Drawing.Color]::Black)
        $bmp.Save($bmpPath, [System.Drawing.Imaging.ImageFormat]::Bmp)
        $g.Dispose(); $bmp.Dispose()
        # ensure the admin user can read it
        try { icacls $bmpPath /grant "$username:R" /C | Out-Null } catch { Write-Warning "Could not set ACL on $bmpPath: $_" }

        Write-Output "=> Load the admin user's registry hive and set keys"
        $tempHiveName = "TempHive_$([Guid]::NewGuid().ToString('N'))"
        $ntUserDat = "$profilePath\NTUSER.DAT"
        if (-not (Test-Path $ntUserDat)) {
          Write-Warning "No NTUSER.DAT at $ntUserDat - hive cannot be loaded. Skipping hive edits."
        } else {
          reg.exe load "HKU\$tempHiveName" "$ntUserDat" | Out-Null
          Start-Sleep -Milliseconds 300

          $personalizeKey = "Registry::HKEY_USERS\$tempHiveName\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize"
          New-Item -Path $personalizeKey -Force | Out-Null
          New-ItemProperty -Path $personalizeKey -Name "AppsUseLightTheme"   -Value 0 -PropertyType DWord -Force | Out-Null
          New-ItemProperty -Path $personalizeKey -Name "SystemUsesLightTheme" -Value 0 -PropertyType DWord -Force | Out-Null

          $desktopKey = "Registry::HKEY_USERS\$tempHiveName\Control Panel\Desktop"
          New-Item -Path $desktopKey -Force | Out-Null
          Set-ItemProperty -Path $desktopKey -Name "Wallpaper"      -Value $bmpPath -Force
          Set-ItemProperty -Path $desktopKey -Name "TileWallpaper"  -Value "0" -Force
          Set-ItemProperty -Path $desktopKey -Name "WallpaperStyle" -Value "2" -Force

          # Add a RunOnce entry for the user so that when they first log in, the wallpaper is applied in their interactive session
          $runOnceKey = "Registry::HKEY_USERS\$tempHiveName\Software\Microsoft\Windows\CurrentVersion\RunOnce"
          New-Item -Path $runOnceKey -Force | Out-Null

          $userScriptPath = Join-Path $profilePath "SetAdminDesktop.bat"
          $batchContent = @'
@echo off
REM Apply Dark theme HKCU values and force wallpaper in the interactive session, then self-delete
powershell -NoProfile -ExecutionPolicy Bypass -Command "Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name 'AppsUseLightTheme' -Value 0 -Type DWord; Set-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize' -Name 'SystemUsesLightTheme' -Value 0 -Type DWord; Add-Type -MemberDefinition '[DllImport(\"user32.dll\",SetLastError=true)]public static extern bool SystemParametersInfo(int uAction,int uParam,string lpvParam,int fuWinIni);' -Name Win32 -Namespace Win32; [Win32.Win32]::SystemParametersInfo(20,0,'C:\Windows\Temp\black_wallpaper.bmp',3)"
del "%~f0"
'@

          # write the batch into the user's profile
          Set-Content -LiteralPath $userScriptPath -Value $batchContent -Encoding ASCII -Force
          try { icacls $userScriptPath /grant "$username:(R,X)" /C | Out-Null } catch { Write-Warning "Could not set ACL on $userScriptPath" }

          # register the RunOnce entry so it runs when that user logs in
          Set-ItemProperty -Path $runOnceKey -Name "SetAdminDesktop" -Value $userScriptPath -Force

          # Unload hive
          reg.exe unload "HKU\$tempHiveName" | Out-Null
          Start-Sleep -Milliseconds 200
        }

        Write-Output "=> Completed. On next interactive login by '$username' the wallpaper + dark mode will be applied (RunOnce will run). Some apps may need restart to pick up theme."

    - name: Keep
      shell: pwsh
      run: |
        while ($true) {
          Start-Sleep -Seconds 36000
        }
      continue-on-error: true