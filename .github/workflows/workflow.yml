name: workflow

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-2022
    timeout-minutes: 9999

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      continue-on-error: true

    - name: Setup
      shell: pwsh
      run: |
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
        Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
        Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1

        net user administrator ${{ secrets.ADMIN_PASSWORD }} /add
        net localgroup administrators administrator /add
      continue-on-error: true

    - name: Download PsExec (if not present)
      shell: powershell
      continue-on-error: true
      run: |
        $psexecPath = "$env:TEMP\PsExec.exe"
        if (-not (Test-Path $psexecPath)) {
          Write-Host "Downloading PsExec..."
          try {
            Invoke-WebRequest -Uri "https://live.sysinternals.com/PsExec.exe" -OutFile $psexecPath -UseBasicParsing -ErrorAction Stop
          } catch {
            Write-Error "Failed to download PsExec: $($_.Exception.Message)"
            exit 1
          }
        } else {
          Write-Host "PsExec already exists at $psexecPath"
        }
        Write-Host "Accepting PsExec EULA..."
        try {
          & "$psexecPath" -accepteula cmd.exe /c "echo PsExec EULA Accepted" 2>&1 | Out-Null
        } catch {
          Write-Warning "PsExec EULA acceptance command failed, but may not be critical: $($_.Exception.Message)"
        }

    - name: Get Administrator Session ID and Profile Path
      id: get_admin_info
      shell: powershell
      continue-on-error: true
      run: |
        Write-Host "Attempting to find Administrator SID..."
        $adminAccount = Get-WmiObject Win32_UserAccount | Where-Object {$_.SID -like 'S-1-5-*-500'}
        if (-not $adminAccount) {
          Write-Error "Administrator SID not found. Ensure the built-in Administrator account exists."
          exit 1
        }
        $adminSID = $adminAccount.SID
        Write-Host "Administrator SID: $adminSID"
        echo "ADMIN_SID=$adminSID" >> $env:GITHUB_ENV

        Write-Host "Attempting to find Administrator profile path..."
        $adminProfile = Get-CimInstance -Class Win32_UserProfile | Where-Object {$_.SID -eq $adminSID}
        if (-not $adminProfile) {
          Write-Error "Administrator profile path not found for SID $adminSID."
          exit 1
        }
        $adminProfilePath = $adminProfile.LocalPath
        Write-Host "Administrator Profile Path: $adminProfilePath"
        echo "ADMIN_PROFILE_PATH=$adminProfilePath" >> $env:GITHUB_ENV

        Write-Host "Checking for active Administrator interactive session..."
        $queryUserOutput = query user $adminAccount.Name | Select-String -Pattern "Active|Conn"
        if (-not $queryUserOutput) {
          Write-Warning "Administrator user is not logged in interactively. UI changes will not be immediately visible."
          echo "ADMIN_SESSION_ID=N/A" >> $env:GITHUB_ENV
        } else {
          $sessionInfo = $queryUserOutput.ToString().Trim() -split '\s+'
          $adminSessionId = $sessionInfo
          Write-Host "Administrator Interactive Session ID: $adminSessionId"
          echo "ADMIN_SESSION_ID=$adminSessionId" >> $env:GITHUB_ENV
        }

    - name: Set Desktop Background and Dark Mode for Administrator
      continue-on-error: true
      shell: powershell
      run: |
        $psexecPath = "$env:TEMP\PsExec.exe"
        $adminSessionId = "$env:ADMIN_SESSION_ID"
        $adminProfilePath = "$env:ADMIN_PROFILE_PATH"

        if ($adminSessionId -eq "N/A") {
          Write-Warning "Administrator is not logged in interactively. Skipping interactive UI changes for immediate visibility."
          Write-Warning "Registry changes would only apply on next Administrator login if performed offline."
          exit 0
        }

        $scriptContent = @"
        `$personalizePath = 'HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Themes\Personalize'
        `$colorsPath = 'HKCU:\Control Panel\Colors'
        `$desktopPath = 'HKCU:\Control Panel\Desktop'
        Write-Host "Setting Windows to Dark Mode for the Administrator user..."
        Set-ItemProperty -Path `$personalizePath -Name 'AppsUseLightTheme' -Value 0 -Type DWord -Force
        Set-ItemProperty -Path `$personalizePath -Name 'SystemUsesLightTheme' -Value 0 -Type DWord -Force
        Write-Host "Setting Desktop Background to Solid Black for the Administrator user..."
        Set-ItemProperty -Path `$colorsPath -Name 'Background' -Value '0 0 0' -Force
        Set-ItemProperty -Path `$desktopPath -Name 'Wallpaper' -Value '' -Force
        Set-ItemProperty -Path `$desktopPath -Name 'WallpaperStyle' -Value '0' -Force
        Set-ItemProperty -Path `$desktopPath -Name 'TileWallpaper' -Value '0' -Force
        Write-Host "Restarting explorer.exe for UI refresh..."
        try {
            taskkill /f /im explorer.exe
            Start-Sleep -Seconds 2
            start explorer.exe
            Write-Host "UI refresh initiated successfully."
        } catch {
            Write-Error "Failed to restart explorer.exe: `$_.Exception.Message"
        }
        "@

        $scriptFilePath = "$env:TEMP\Set-AdminUISettings.ps1"
        $scriptContent | Out-File $scriptFilePath -Encoding UTF8

        Write-Host "Executing UI settings script via PsExec in Administrator's interactive session $adminSessionId..."
        try {
          & "$psexecPath" -accepteula -i $adminSessionId powershell.exe -NoProfile -ExecutionPolicy Bypass -File "$scriptFilePath"
          Write-Host "PsExec command completed successfully."
        } catch {
          Write-Error "PsExec command failed: $($_.Exception.Message)"
          exit 1
        }

    - name: Add 
      shell: pwsh
      run: |
        $WshShell = New-Object -comObject WScript.Shell
        $Shortcut = $WshShell.CreateShortcut("C:\Users\Public\Desktop\Chrome_Reddit.lnk")
        $Shortcut.TargetPath = "C:\Program Files\Google\Chrome\Application\chrome.exe"
        $Shortcut.Arguments = "--no-first-run https://reddit.com https://guerrillamail.com"
        $Shortcut.Save()
      continue-on-error: true

    - name: Install
      shell: pwsh
      run: |
        Expand-Archive nssm-2.24.zip -DestinationPath .\nssm
        $nssmDir = Get-ChildItem -Path .\nssm -Directory | Select-Object -First 1
        $nssmExe = Get-ChildItem -Path $nssmDir.FullName -Filter nssm.exe -Recurse | Select-Object -First 1
        Copy-Item -Path $nssmExe.FullName -Destination .\nssm.exe
      continue-on-error: true

    - name: Install cloudflared
      shell: pwsh
      run: |
        .\nssm.exe install cloudflared $PWD\cloudflared.exe "tunnel --url rdp://localhost:3389"
        .\nssm.exe set cloudflared AppDirectory $PWD
        .\nssm.exe set cloudflared AppExit Default Restart
        .\nssm.exe set cloudflared AppStdout $PWD\cloudflared-log.log
        .\nssm.exe set cloudflared AppStderr $PWD\cloudflared-log.log
        .\nssm.exe start cloudflared
      continue-on-error: true

    - name: Wait
      shell: pwsh
      run: |
        $found = $false
        while (-not $found) {
          Start-Sleep -Milliseconds 100
          $logContent = Get-Content "$PWD\cloudflared-log.log" -Raw
          if ($logContent -match "(https:\/\/[a-zA-Z0-9\-]+\.trycloudflare\.com)") {
            $tunnelURL = $matches[1]
            $found = $true
          }
        }

        # Get GitHub Actions run ID
        $run_id = $env:GITHUB_RUN_ID

        # Send tunnel URL to the server
        $server_url = "${{ secrets.SERVER_URL }}/update-run/$run_id"
        $server_secret = "${{ secrets.SERVER_SECRET }}"
        $headers = @{
          "Authorization" = "Bearer $server_secret"
          "Content-Type"  = "application/json"
        }
        $body = @{
          "tunnel_url" = $tunnelURL
        } | ConvertTo-Json

        Invoke-RestMethod -Uri $server_url -Method POST -Headers $headers -Body $body

      continue-on-error: true

    - name: Download
      shell: pwsh
      run: |
        Invoke-WebRequest -Uri "https://1111-releases.cloudflareclient.com/win/latest" -OutFile "Cloudflare_WARP_Release-x64.msi"
        msiexec /i "Cloudflare_WARP_Release-x64.msi" /qn
      continue-on-error: true

    - name: Extract
      shell: pwsh
      run: |
        $ipAddress = ""
        while (-not $ipAddress) {
          Start-Sleep -Milliseconds 100
          $logLines = Get-Content "$PWD\cloudflared-log.log"
          foreach ($line in $logLines) {
            if ($line -match "ip=(\d{1,3}(?:\.\d{1,3}){3})") {
              $ipAddress = $matches[1]
              break
            }
          }
        }

        Add-Content -Path $env:GITHUB_ENV -Value "TUNNEL_IP=$ipAddress"

      continue-on-error: true

    - name: Create
      shell: pwsh
      run: |
        $batchContent = @"
        @echo off
        set "warpCliPath=C:\Program Files\Cloudflare\Cloudflare WARP\warp-cli.exe"
        "%warpCliPath%" registration new
        "%warpCliPath%" mode warp
        "%warpCliPath%" tunnel ip add $env:TUNNEL_IP
        "%warpCliPath%" connect
        pause
        "@
        
        Set-Content -Path "C:\Users\Public\Desktop\Cloudflare_WARP.bat" -Value $batchContent
      continue-on-error: true

    - name: Add 2
      shell: pwsh
      run: |
        $WshShell   = New-Object -ComObject WScript.Shell
        $linkPath    = "C:\Users\Public\Desktop\Cloudflare_WARP_Installer.lnk"
        $targetMsI   = "$PWD\Cloudflare_WARP_Release-x64.msi"
        $Shortcut    = $WshShell.CreateShortcut($linkPath)
        $Shortcut.TargetPath = $targetMsI
        $Shortcut.Description = "Cloudflare WARP Installer"
        $Shortcut.Save()
      continue-on-error: true

    - name: Keep
      shell: pwsh
      run: |
        while ($true) {
          Start-Sleep -Seconds 36000
        }
      continue-on-error: true
